/* autogenerated by Processing revision 1289 on 2023-01-25 */
import processing.core.*;
import processing.data.*;
import processing.event.*;
import processing.opengl.*;

import gifAnimation.*;

import java.util.HashMap;
import java.util.ArrayList;
import java.io.File;
import java.io.BufferedReader;
import java.io.PrintWriter;
import java.io.InputStream;
import java.io.OutputStream;
import java.io.IOException;

public class Sun extends PApplet {



int br;
int pc = 150;
float nm = 10;
float o = .0075f;

Loop a;
Loop b;
Loop c;
Stars s;

GifMaker gif;
float ft = TAU/o;
boolean gs = false;

public void setup() {
  /* size commented out by preprocessor */;
  frameRate(30);
  noStroke();
  br = width/6;
  a = new Loop(pc, width/5, 220, nm+2, 0, o);
  b = new Loop(pc, width/7, 110, nm, 0, o);
  c = new Loop(pc, br, 10, nm, 0, o);
  
  s = new Stars(500);
  
  gif = new GifMaker(this, "star.gif");
  gif.setRepeat(0);
}

public void draw() {
  print(frameRate, "\n");
  background(0);
  s.render();
  translate(width/2,height/2);
  
  fill(255, 255, 0, 150);
  a.render();
  fill(255, 100, 0, 255);
  b.render();
  fill(255,50,0,255);
  c.render();
  
  a.update();
  b.update();
  c.update();
  
  handleGif();
}

public void handleGif() {
  gif.setDelay(1000/30);
  gif.addFrame();
  if(frameCount > ft && !gs) {
   gs = gif.finish();
   if(gs) {
     print("Gif successfully exported");
    }
    else {
      print("Gif failed to export");
    }
  }
}
class Loop {
  int pc;   // Point count
  float nm; // Max noise
  float ba; // Base amplitude
  float a;  // Amplitude
  float po;  // Phase
  float o;  // Velocity through noise space
  
  PVector[][] points;
  int f = 0;
  Loop(int pointCount, float baseAmp, float amplitude, float noiseMax, float phase, float omega) {
    this.pc = pointCount;
    this.nm = noiseMax;
    this.ba = baseAmp;
    this.a = amplitude;
    this.po = phase;
    this.o = omega;
    
    float dt = radians(360/pc);
    points = new PVector[floor(TAU/o)][floor(TAU/dt)];  // OUT OF BOUNDS ERROR WHY
    float p = po;
    for(int i = 0; i < points.length; i++) {
      float theta = 0;
      for(int j = 0; j < points[0].length; j++) {
        float xoff = map(cos(theta + p), -1, 1, 0, nm);
        float yoff = map(sin(theta), -1, 1, 0, nm);
        float r = ba + a*noise(xoff, yoff);
        float x = r * cos(theta);
        float y = r * sin(theta);
        points[i][j] = new PVector(x, y);
        theta += dt;
      }
      p += o;
    }
  }
  
  public void update() {
    if (f > points.length - 2) { f = 0; }
    else { f++; }
  }
  
  public void render() {    
    beginShape();
    for(PVector point : points[f]) {
      vertex(point.x,point.y);
    }
    endShape(CLOSE);
  }
  

}
class Stars {
  PVector[] stars;
  
  Stars(int starCount) {
    stars = new PVector[starCount];
    for(int s = 0; s < stars.length; s++) {
      float x = random(0, width);
      float y = random(0, height);
      stars[s] = new PVector(x,y);
    }
    
  }
  
  public void render() {
    for(PVector star : stars) {
      fill(255, random(100,255));
      ellipse(star.x, star.y, 2, 2);
    }
  }
}


  public void settings() { size(700, 700); }

  static public void main(String[] passedArgs) {
    String[] appletArgs = new String[] { "Sun" };
    if (passedArgs != null) {
      PApplet.main(concat(appletArgs, passedArgs));
    } else {
      PApplet.main(appletArgs);
    }
  }
}
